/* 
 * Макроопределение завершения работы.
 * Аргументы:
 * 	- код завершения программы
 *
 * После выполнения макровызова изменяются регистры: %eax, %ebx
 * См. также 'man 2 exit'
*/
.macro Exit ret_val
	movl $1, %eax 		    # номер сист. вызова exit номер 1
	movl \ret_val, %ebx 	# код выхода
	int $0x80 		        # выполнить системный вызов
.endm  

/*
 * Мароопределение для процедуры считывания одного символа из стандартного ввода
 * Аргументы:
 * 	- адрес буффера для считывания символа
 * Результат:
 *	- в %eax количество считанных символов
 *	- по адресу buf_addr - считанный символ
 * 
 * После выполнения макровызова изменяются регистры: %eax, %ebx, %ecx, %edx
 * См. также 'man 2 read'
*/
.macro Getchar buf_addr
	movl $3, %eax		# номер сист. вызова read
	movl $0, %ebx		# параметр 1: дескриптор стандартного ввода
	movl \buf_addr, %ecx	# параметр 2: адрес буфера (он же - фактический 
	     			        # параметр макровызова)
	movl $1, %edx		# параметр 3: количество байтов для чтения
	int $0x80		    # выполнить системный вызов
.endm

/*
 * Мароопределение для процедуры вывода строки в стандартный вывод
 * Аргументы:
 * 	- Строка для вывода.
 *
 * Приметр макровызова:
 *	Puts "Текст выводимой строки" 
 *
 * Результат:
 *	- выводит в стандартный вывод символы заданной строки,
 *	  а также символ перевода строки
 *	
 * После выполнения макровызова изменяются регистры: %eax, %ebx, %ecx, %edx
 * См. также 'man puts', 'man 2 write'
*/
.macro Puts string      #Вывод строки без перевода символа строки
.data
str\@: .ascii "\string" # формирование фактической строки для вывода

strlen\@ = . - str\@    # получение значения длины строки

.text
    movl $4, %eax       # номер сист. вызова write
    movl $1, %ebx       # параметр 1: дескриптор стандартного вывода
    movl $str\@, %ecx   # параметр 2: адрес памяти с выводимыми символами
    movl $strlen\@, %edx # параметр 3: количество байтов для вывода
    int $0x80           # выполнить системный вызов
.endm

.macro Division        # Деление числа
.text
    check_minus_p\@:   # Проверяем на минус
    movl $0, %esi
    cmpl $0, result    # в сумме получилось число меньше 0?
    jl place_minus\@   # ДА - на вывод минуса
    jmp place_numbers\@  # на перевод суммы в систему счисления ebx

place_minus\@: # Если минус - выведем его и возьмем число по модулю
    movl %ebx, %ebp    # указываем регистровый указатель bp на базу bx (передаем код основания в %ebp)
    Puts "-"           # выводим сначала знак -
    movl $0, %eax      # помещаем 0 после макровызова Puts
    movl result, %eax  # помещаем сумму в регистр %eax
    movl %ebp, %ebx    # обратно помещаем основание в %ebx
    negl %eax          # изменяем знак на противоположный у суммы
    jmp place_numbers\@   # на перевод суммы в систему счисления ebx
	
place_numbers\@:       # Делим
    movl $0, %edx      # готовим деление
    idiv %ebx          # делим на основание, остаток в %edx
    add $'0', %edx     # увеличиваем на код 0, чтобы получить символ
    mov %edx, buf(%esi) # записываем символ в буфер
    inc %esi           # увеличиваем на 1, чтобы узнать, сколько символов будет в числе
    cmp $0, %eax       # частное = 0?
    je out\@ # ДА - идем на разворот буфера
    jmp place_numbers\@ # НЕТ - продолжаем делить
    out\@:
    int $0x80
.endm

.macro Putn           # Вывод числа: eax - число, ebx - основание 
.text
preinverted\@:        # Подготовимся к развороту буфера с цифрами
    movl %esi, %ecx   # помещаем в ecx количество цифр суммы
    dec %ecx          # указать на предыдущий адрес буфера
    movl %esi, %eax   # помещаем в eаx количество символов суммы
    movl $0, %edx
    movl $2, %ebx     # будем узнавать, сколько символов нам нужно поменять (будут в %eax)
    idivl %ebx        # делим, остаток уходит в %edx
    movl $0, %esi
    jmp inverted\@    # переходим на сам разворот буфера

inverted\@:
    cmp %eax, %esi    # все ли символы поменяли местами
    je put_out\@      # ДА - переходим на вывод числа на экран
    movb buf(%esi), %bl # помещаем код символа к %bl по значению %esi
    movl %ecx, %edx   # помещаем в %edx количество позиций буфера
    sub %esi, %edx    # узнаем, какие места будем менять
	# далее осуществляем обмен символов местами 
    movb buf(%edx), %bh 
    movb %bl, buf(%edx)
    movb %bh, buf(%esi)
    inc %esi          # указать на следующий адрес буфера для следующего символа
    jmp inverted\@    # возвращаемся для дальнешего разворота

put_out\@:            # Вывод числа на экран
	inc %ecx          # указать на следующий адрес буфера 
	movl $4, %eax     # номер сист. вызова write
	movl $1, %ebx     # параметр 1: дескриптор стандартного вывода	
	movl %ecx, %edx   # параметр 2: адрес памяти с выводимыми символами
    movl $buf, %ecx   # количество байтов для вывода
    int $0x80 # выполнить системный вызов
.endm


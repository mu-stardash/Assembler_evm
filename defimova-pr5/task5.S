/**
 * Программа, получающая вектор, элементы которого вычисляются по формуле b(i) = A(l,i) + A(i,k)
 *
 * Copyright (c) 2020, Dasha Efimova <dashulya0301178@gmail.com>
*/

.include "my-macro"	# подключение файла с макроопределениями
	
.bss
	.lcomm buf, 100 # буфер для хранения прочитанных символов. Размер - 100 байт
	.lcomm k, 1 	# буфер для чтения текущего символа. Размер - 1 байт
	.lcomm l, 1 	# буфер для чтения текущего символа. Размер - 1 байт
	
	
.data # секция данных, распределение памяти

result:	.long 0		     	# Используется для деления числа, для последующего вывода числа на экран 
clean:	.long 0		    	# Используется при очистки буфера
b:	.long 0,0,0,0,0,0	# Искомый вектор
column:	.long 0		        # Номер столбца
string:	.long 0			# Номер строки
num:	.long 0			# Помогает записать число в вектор
A:			        # Матрица 6х6

	.long 11,-12,13,-14,15,16
	.long 21,22,-23,24,25,26
	.long 31,32,33,34,-35,36
	.long -41,42,43,44,45,46
	.long 51,52,53,54,-55,56
	.long 61,62,63,64,65,-66

.text # секция команд процесора

.global _start # точка входа - глобальная метка

_start:
	sub %esi, %esi     			# указатель адреса байта в буфере символов (индексный регистр)
	Puts "Enter column (l) number: "

kbd_input_l:
    Getchar $l          		# макровызов ввода символа со стандартного ввода
    cmpl $0, %eax   			# Конец файл - EOF (введено 0 символов) ?
    je stop         			# ДА - на завершение программы
    cmpb $'\n', l   			# это символ перевода строки ?
    je sum1		                # ДА - переход на суммирование последнего числа
    cmpb $'6',l				# Код символа больше кода 6? 
    ja kbd_input_l	                # ДА - игнорируем его
    cmpb $'1',l		        	# Код символа меньше кода 1?
    jb kbd_input_l			# ДА - игнорируем его
    movb l, %al     	        	# код из l пишем в al
    movb %al,buf(%esi)  	        # Загрузить содержимое al (введенный символ) в байт по адресу buf + esi (буфер для вводимых символов)
    incl %esi			        # указать на следующий адрес буфера
    jmp kbd_input_l   	         	# на ввод следующего символа
          

sum1:
    cmpl $0, %esi			# регистр равен нулю?
    je error1	                        # ДА - переходим на вывод сообщения об ошибки
    decl %esi		                # указать на предыдущий адрес буфера
    sub %eax, %eax			# очищаем регистр 
    movl $'0', %ebx   	        	# в ebx заносим код 0
    movb buf(%esi), %al 	        # байтовое перемещение, из буфера buf + esi забирается код цифрового символа и размещается в младшем байте %al  
    movl $0, buf(%esi)  	        # в буфер помещаем 0
    sub %ebx, %eax     			# преобразовываем код символа цифры в само число
    movl %eax, column 	                # перемещаем число в переменную в памяти для дальнейшей работы
    sub %esi, %esi		        # очистка регистра
    Puts "Enter line(k) number: "

kbd_input_k:
    Getchar $k          	        # макровызов ввода символа со стандартного ввода
    cmpl $0, %eax   			# Конец файл - EOF (введено 0 символов) ?
    je stop         			# ДА - на завершение программы
    cmpb $'\n', k   			# это символ перевода строки ?
    je sum2				# ДА - переход на суммирование последнего числа
    cmpb $'6',k				# Код символа больше кода 6?
    ja kbd_input_k			# ДА - игнорируем его
    cmpb $'1',k				# Код символа меньше кода 1?
    jb kbd_input_k		        # ДА - игнорируем его
    movb k, %al     			# код из с пишем в al
    movb %al,buf(%esi)  	        # Загрузить содержимое al (введенный символ) в байт по адресу buf + esi (буфер для вводимых символов)
    incl %esi				# указать на следующий адрес буфера
    jmp kbd_input_k   		        # на ввод следующего символа
          

sum2:
    cmpl $0, %esi			# регистр равен нулю?
    je error2				# ДА - переходим на вывод сообщения об ошибки
    decl %esi		                # указать на предыдущий адрес буфера
    sub %eax, %eax			# очищаем регистр
    movl $'0', %ebx   			# в ebx заносим код 0
    movb buf(%esi), %al                 # байтовое перемещение, из буфера buf + esi забирается код цифрового символа и размещается в младшем байте %al  
    movl $0, buf(%esi)  		# в буфер помещаем 0
    sub %ebx, %eax     			# преобразовываем код символа цифры в само число 
    movl %eax, string		        # перемещаем число в переменную в памяти для дальнейшей работы
    sub %esi, %esi			# очистка регистра
    mov $A, %edx     	                # Установка начального значения цикла по строкам

Next_String1:

   subl %ebx, %ebx	  		# Установка начального значения цикла по столбцам	
	
Next_Row1:		

	movl (%edx,%ebx,4), %eax        # адрес первого элемента А[11] 
	incl %ebx		  	# j++ 
	cmpl column, %ebx		# столбцы равны заданному числу?
	jne  Next_Row1          	# НЕТ - идем дальше
	subl %ecx, %ecx			# база = 0 - на 1-ый элемент 
	movl num, %ecx				
	addl %eax, b(%ecx)		# 1-ый элемент в будущем векторе
	addl $4, num			# Добавляем 4 для перехода на следущий элемент вектора
	addl $24, %edx	  		# Добавляем 24 (4*6=24) для перехода на следущую строку в матрице
	cmpl $A+144, %edx 		# строки закончились? (24*6=144)
	jne  Next_String1       	# НЕТ - идем дальше
	movl $0, num			# обнуляем num
	
	mov $A, %edx			# Установка начального значения цикла по строкам
	subl %ebx, %ebx			# Установка начального значения цикла по столбцам

Next_String2:		

	movl (%edx, %ebx,4), %eax       	# адрес первого элемента А[11]
	incl %esi		  	    	# указать на следующий адрес буфера
	addl $24, %edx		  		# добавляем к адресу 24 для перехода на следующую строку в матрице
	cmpl string, %esi		  	# строка равна заданному числу?
	jne  Next_String2	  		# НЕТ - идем дальше
	subl $24, %edx		  		# Возвращаемся к предыдущей строке
	jmp  Next_Row2		  		# Переходим для

Next_Row2:

	subl %ecx, %ecx				# база = 0 - на 1-ый элемент
	movl num, %ecx				
	addl %eax, b(%ecx)			# 1-ый элемент в будущем векторе
	jo error3
	addl $4, num				# Добавляем 4 для перехода на следующий элемент вектора
	incl %ebx			        # j++
	movl (%edx, %ebx,4), %eax 	        # адрес первого элемента в строке
	cmpl $6, %ebx		  		# столбцы закончились?
	jne  Next_Row2		  		# НЕТ - идем дальше
	movl $0, num		  		# обнуляем num
	subl %esi, %esi		  		# очищаем регистр

	Puts "B(i)= "
	
put_out:	

	movl num, %esi		                # Присваиваем регистру %esi значение num
	cmpl $6, %esi	                	# Вывели все числа?
	je stop			                # ДА - переходим на конец программы
	movl b(,%esi,4), %eax	                # Записываем значение вектора в регистр %eax
	movl %eax, result	                # Записывает значение в переменную result для последущего деления числа
	movl $10, %ebx	           	        # Основание системы счисления (для деления)
	movl $0, %esi		                # Очищаем регистр (для использования его в делении)
	Division		                # макровызов - деление числа
	movl %esi, clean		        # Записать в переменную clean количество цифр в числе
	Putn                                    # макровызов вывода числа
	Puts " "		                # макровызов вывода строки на стандартный вывод
	movl clean, %esi		        # Заносим в регистр количество цифр в числе
	
cleaning_buf:
	
	movb $0, buf(%esi)   	                # очищаем буфер
	decl %esi		                # уменьшаем регистр на 1
	cmpl $0, %esi		                # значение в регистре равно 0?
	jne cleaning_buf	                # НЕТ - идем дальше
	incl num		                # увеличиваем num
	jmp put_out		                # переходим на ввод следущего числа вектора

error1:
	Puts "Enter a number from 1 to 6\n"
	movl $0, %esi	                        # очищаем регистр
	jmp kbd_input_l		                # переходим на ввод числа
	
error2:
	Puts "Enter a number from 1 to 6\n"
	movl $0, %esi		                # очищаем регистр
	jmp kbd_input_k		                # переходим на ввод числа

error3:
    Puts "Amount overflowed. Program completion\n"
	jmp stop
	
stop:
	Puts "\n"
	Exit $0                                 # конец работы, возврат в ОС (макро из файла my-macro)
		
.end                                            # последняя строка исходного текста	

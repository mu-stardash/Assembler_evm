/* 
 * Макроопределение завершения работы.
 * Аргументы:
 * 	- код завершения программы
 *
 * После выполнения макровызова изменяются регистры: %eax, %ebx
 * См. также 'man 2 exit'
*/
.macro Exit ret_val
	movl $1, %eax 		    # номер сист. вызова exit номер 1
	movl \ret_val, %ebx 	# код выхода
	int $0x80 		        # выполнить системный вызов
.endm  


/*
 * Мароопределение для процедуры считывания одного символа из стандартного ввода
 * Аргументы:
 * 	- адрес буффера для считывания символа
 * Результат:
 *	- в %eax количество считанных символов
 *	- по адресу buf_addr - считанный символ
 * 
 * После выполнения макровызова изменяются регистры: %eax, %ebx, %ecx, %edx
 * См. также 'man 2 read'
*/
.macro Getchar buf_addr
	movl $3, %eax		# номер сист. вызова read
	movl $0, %ebx		# параметр 1: дескриптор стандартного ввода
	movl \buf_addr, %ecx	# параметр 2: адрес буфера (он же - фактический 
	     			        # параметр макровызова)
	movl $1, %edx		# параметр 3: количество байтов для чтения
	int $0x80		    # выполнить системный вызов
.endm

/*
 * Мароопределение для процедуры вывода строки в стандартный вывод
 * Аргументы:
 * 	- Строка для вывода.
 *
 * Приметр макровызова:
 *	Puts "Текст выводимой строки" 
 *
 * Результат:
 *	- выводит в стандартный вывод символы заданной строки,
 *	  а также символ перевода строки
 *	
 * После выполнения макровызова изменяются регистры: %eax, %ebx, %ecx, %edx
 * См. также 'man puts', 'man 2 write'
*/
.macro Puts string #Вывод строки без перевода символа строки
.data
    str\@: 	.ascii "\string"  # формирование фактической строки для вывода
	
    strlen\@ = 	. - str\@           # получение значения длины строки

.text
	movl $4, %eax		# номер сист. вызова write
	movl $1, %ebx		# параметр 1: дескриптор стандартного вывода	
	movl $str\@, %ecx	# параметр 2: адрес памяти с выводимыми символами
	movl $strlen\@, %edx 	# параметр 3: количество байтов для вывода
	int $0x80		# выполнить системный вызов
.endm
			
.macro Putsn string #Вывод строки с переводом символа
.data
    str\@: 	.ascii "\string\n"  
    strlen\@ = 	. - str\@           
.text
	movl $4, %eax		
	movl $1, %ebx			
	movl $str\@, %ecx	
	movl $strlen\@, %edx 	
	int $0x80		
.endm

.macro Putn # Вывод числа: eax - сумма, ebx - основание
.bss
	.lcomm buf1\@, 10
.data
mins\@: .short -1

.text
place_numbers\@:            # Делим
	movl $0, %edx        # готовим деление
	idivw %bx            # делим на основание, частное уходит в %edx 
	add $'0', %dl        # увеличиваем на код 0, чтобы получить символ
	movb %dl, buf1\@(%esi) # записываем символ в буфер
	inc %esi             # увеличиваем на 1, чтобы узнать, сколько символов будет в числе
	cmp $0, %ax          # частное = 0?
	je preinverted\@      # ДА - готовимся к развороту буфера с символами
	jmp place_numbers\@  # НЕТ - продолжаем делить

preinverted\@:           #Подготовимся к развороту буфера с цифрами
	movl %esi, %ecx      # помещаем в ecx количество цифр суммы
	dec %ecx             # указать на предыдущий адрес буфера 
	movl %esi, %eax      # помещаем в eаx количество символов суммы
	movl $0, %edx
	movl $2, %ebx        # будем узнавать, сколько символов нам нужно поменять (будут в %eax)
	idivl %ebx           # делим, частное уходит в %edx 
	movl $0, %esi
	jmp inverted\@        # переходим для разворота буфера

inverted\@:              # Разворот буфера
	cmp %eax, %esi       # все символы поменяли местами? 
	je put_out\@         # ДА - переходим на вывод
	movb buf1\@(%esi), %bl # помещаем код символа к %bl по значению %esi (для последующего перемещения)
	movl %ecx, %edx      # помещаем в %edx количество позиций буфера
	sub %esi, %edx       # узнаем, на какое место менять
	# далее осуществляем обмен символов местами 
	movb buf1\@(%edx), %bh
	movb %bl, buf1\@(%edx)
	movb %bh , buf1\@(%esi)
	inc %esi             # указать на следующий адрес буфера для следующего символа
	jmp inverted\@        # переход на разворот буфера

put_out\@: #Вывод
	inc %ecx             # указать на следующий адрес буфера 
	movl $4, %eax        # номер сист. вызова write
	movl $1, %ebx        # параметр 1: дескриптор стандартного вывода	
	movl %ecx, %edx      # параметр 2: адрес памяти с выводимыми символами
	movl $buf1\@, %ecx   # параметр 3: количество байтов для вывода
	int $0x80            # выполнить системный вызов
.endm


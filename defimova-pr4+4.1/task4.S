/**
 * Программа, суммирующая одноцифровые числа (положительные) и выводящая их в 10, 2, 8 с.с. 
 *
 * Copyright (c) 2020, Dasha Efimova <dashulya0301178@gmail.com>
*/

.include "my-macro"

.bss
    .lcomm buf, 10 # буфер для хранения прочитанных символов. Размер - 10 байт
    .lcomm c, 1 # буфер для чтения текущего символа. Размер - 1 байт

.data # секция данных, распределение памяти
      #соотв. конструкция языка C и коммент.
result: .word 0   # Результат суммы (размер 2 байта)
ten:    .word 10  # константа для деления на 10
two:	.word 2   # константа для деления на 2
eight:	.word 8	  # константа для деления на 8

.text                # секция команд процесора 
    .global _start   # точка входа - глобальная метка

_start:
    sub %esi, %esi   # указатель адреса байта в буфере символов (индексный регистр)

kbd_input:
  
        Getchar $c      # макровызов ввода символа со стандартного ввода
        cmpl $0, %eax   # Конец файл - EOF (введено 0 символов) ?
        je stop         # Да - на завершение программы
        cmpb $'\n', c   # это символ перевода строки ?
        je presum       # ДА - пытаемся прибавить последний символ
        cmpb $'-', c    # введен знак -?
        je kbd_input    # ДА - игнорируем его
        cmpb $'9', c    # код больше кода символа '9' ?
        ja kbd_input    # ДА - игнорируем его
        cmpb $'0', c    # код меньше кода символа '0' ?
        jb kbd_input    # ДА - игнорируем его
        movb c, %al     # код из с пишем в al
        movb %al, buf(%esi)  # Загрузить содержимое al (введенный символ) в байт по
			                 # адресу buf + esi (буфер для вводимых символов)
		incl %esi       
        jmp kbd_input   # на ввод следующего символа
		
presum:
        movl $0, %edx   # Подготавливаем регистры для суммы
        movl $0, %ecx
        movl $0, %eax
        jmp summ        # на суммирование

summ:
    decl %esi
    cmpl $-1, %esi      # если мы не ввели число, а нажали enter
	je enter            # то переходим к выводу сообщения
	movb buf(%esi), %al	# байтовое перемещение, из буфера buf + esi забирается код цифрового символа и размещается в младшем байте %al  
	subl $48, %eax		# преобразовываем код символа цифры в само число 
    movw result, %bx        # копируем результат(сумму) в ebx
	add %ax, %bx            # пробуем сложить
    jc error                # если произошло переполнение, то переходим на вывод сообщения
    movw %bx, result        # получившуюся сумму переносим обратно в result
    jmp output              # переход на вывод суммы

output: 
	mov result, %ax      # помещаем результат(сумму) в eax
	mov $10, %ebx        # помещаем 10 в ebx 
	Putn                 # макровызов для вывода суммы по основанию ebx 
	Puts " "             # макровызов вывода строки на стандартный вывод
        movl $0, %esi        # очищаем регистр
	movb $0, buf(%esi)   # очищаем буфер

	mov result, %ax      # помещаем результат(сумму) в eax
	mov $2, %ebx         # помещаем 2 в ebx
	Putn                 # макровызов для вывода суммы по основанию ebx 
	Puts " "             # макровызов вывода строки на стандартный вывод
        movl $0, %esi        # очищаем регистр
	movb $0, buf(%esi)   # очищаем буфер

	mov result, %ax      # помещаем результат(сумму) в eax
	mov $8, %ebx         # помещаем 8 в ebx
	Putn                 # макровызов для вывода суммы по основанию ebx 
	Putsn                # макровызов вывода строки с символом перевода строки
	movl $0, %esi        # очищаем регистр
	movb $0, buf(%esi)   # очищаем буфер
	jmp kbd_input        # на ввод следующего символа

enter:
    Puts "Вы не ввели цифру\n"
	movl $0, %esi
	jmp kdb_input
	
error:
	Puts "Сумма переполнена. Конец программы" # сообщение о переполнении суммы
	jmp stop                                  # на завершение программы
 
 
stop:
    Exit $0

.end



		


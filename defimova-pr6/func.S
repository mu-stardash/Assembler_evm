/*
 *   Подпрограмма, которая считает количество нечисловых символов в данном массиве
 *   Copyright (c) 2020, Dasha Efimova <dashulya0301178@gmail.com>
 */
    .include "my-macro" # подключение файла с макроопределениями

.data # секция данных, распределение памяти


Symbols:
        .asciz  "91A23B456C789" # массив символьных кодов
#                                 цифр и "не цифр"

lokal:
	.long 0 # переменная для показа локальной переменной в стеке

.bss    # секция общей памяти (для результата)

.lcomm  Numbers, 40             # массив 4-х байтовых значений цифр

        .text # секция команд процесора

.type   Read_Sym, @function     # функция циклической обработки массива

Read_Sym:

/*
        Читает <Параметр1> символов из массива <Параметр2>
        и передает их на обработку функции Trans_Sym.
        Результат размещается в массив Numbers
*/
#       Стандартный пролог фунции

        pushl %ebp       # сохранить в стеке значение, бывшее в вызывающей
        movl  %esp, %ebp # обеспечить адресный доступ к параметрам и 
                         # локальным переменнным в стеке путем базовой 
                         # адресации через ebp
        subl  $12, %esp  # завести три 4-х байтовых локальную переменную
			 # 1 - счётчик нечисловых символов
			 # 2 - подсчитывает количество свободных мест в Numbers
                         # 3 - подсчитывает элемнты в Symbols

#       Тело функции

        subl %ecx, %ecx   # инициализация счетчика цикла 

NextSym:
        movl 12(%ebp), %edx  # адрес второго параметра-массива в edx

#       вызов функции Trans_Sym



        subl %ebx, %ebx             # подготовка ebx для записи символа
	movl -12(%ebp), %ecx        # Заносим в %ecx значение третьей локальной переменной
        movb (%edx,%ecx,1), %bl     # символ в ebx

	cmpl $'9', %ebx             # код больше кода символа '9' ?
	ja not_num                  # ДА - переходим на метку not_num
	cmpl $'0', %ebx             # код меньше кода символа '0' ?
	jb not_num                  # ДА - переходим на метку not_num

#       Начинаем вызов Trans_Sym

        pusha   # сохранить регистры текущей функции Read_Sym

        pushl %ebx                # Параметр функции Trans_Sym (код 
                                  # символа из массива) в стек
        call Trans_Sym

        addl    $4,%esp      # очиcтить стек от параметров Trans_Sym

        movl -8(%ebp), %ecx 	       # Записать в %ecx значение второй локальной переменной
        movl    %eax, Numbers(,%ecx,4) # записать результат Trans-Sym (в массив полученное число)
        movl -12(%ebp), %ecx	       # Записать в %ecx значение третьей локальной переменной

        popa   # восстановть регистры Read_Sym
	jmp after_trans

not_num:
        incl -4(%ebp)		       # Увеличиваем на 1 счетчик нечисловых символов 
	incl -12(%ebp)		       # Увеличиваем 3 переменную на 1
	jmp NextSym		       # Переходим на метку NextSym


after_trans:
        incl  -8(%ebp)	     # Увеличиваем 2 переменную
        incl %ecx            # наращиваем счетчик цикла
        movl %ecx, -12(%ebp) # Записать в 3 переменную значение регистра %ecx
        movl -8(%ebp),%ecx   # Записать в регистр %ecx значение второй переменной
        cmpl 8(%ebp), %ecx   # счетчик равен первому параметру?
        jne NextSym          # ДА, повторяем
                             # НЕТ - выходим из цикла

#       Стандартный эпилог функции

	movl -4(%ebp), %eax  # Присваиваем найденное значение регистру %eax
        movl %ebp, %esp      # восстановить указатель стека
        popl %ebp            # восстановить ebp
        ret                  # возврат в вызывающую

# конец Read_Sym

/*
    Функция преобразования кода символа в числовое значение
    <Пареметр1> преобразуется в число и возвращается в eax */

.type   Trans_Sym, @function

Trans_Sym:

#       Стандартный пролог фунции

        pushl %ebp       # сохранить в стеке значение, бывшее в вызывающей
        movl  %esp, %ebp # обеспечить адресный доступ к параметрам и 
                         # локальным переменнным в стеке путем базовой 
                         # адресации через ebp

#       тело функции

        movl 8(%ebp), %eax  # параметр в eax
        subl $0x30, %eax    # получение числового значения

#       Стандартный эпилог функции

        movl %ebp, %esp # восстановить указатель стека
        popl %ebp       # восстановить ebp
        ret             # возврат в вызывающую


.global _start # точка входа - глобальная метка

_start:

                nop

                pusha   # сохранение регистров главной программы

                pushl $Symbols  # Параметр-2 - адрес массива в стек
                pushl $8        # Параметр-1 в стек

                call Read_Sym   # вызов функции

                addl $8,%esp    # очистить стек от параметров Read_Sym
		movl %eax, lokal # присваиваем переменной lokal искомое значение
                popa         # восстановить регистры главной програмы

                Finish # конец работы, возврат в ОС (макро из файла my-macro)
                .end   # последняя строка исходного текста


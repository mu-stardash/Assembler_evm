/* 
 * Макроопределение завершения работы.
 * Аргументы:
 * 	- код завершения программы
 *
 * После выполнения макровызова изменяются регистры: %eax, %ebx
 * См. также 'man 2 exit'
*/
.macro Exit ret_val
	movl $1, %eax 		    # номер сист. вызова exit номер 1
	movl \ret_val, %ebx 	# код выхода
	int $0x80 		        # выполнить системный вызов
.endm  

/*
* Макроопределение для процедуры считывания одного символа из
стандартного ввода
* Аргументы:
* - адрес буффера для считывания символа
* Результат:
* - в %eax количество считанных символов
* - по адресу buf_addr - считанный символ
*
* После выполнения макровызова изменяются регистры: %eax, %ebx, %ecx,
%edx
* См. также 'man 2 read'
*/
.macro Getchar buf_addr
	movl $3, %eax		# номер сист. вызова read
	movl $0, %ebx		# параметр 1: дескриптор стандартного ввода
	movl \buf_addr, %ecx	# параметр 2: адрес буфера (он же - фактический 
	     			        # параметр макровызова)
	movl $1, %edx		# параметр 3: количество байтов для чтения
	int $0x80		    # выполнить системный вызов
.endm

/*
* Макроопределение для процедуры вывода строки в стандартный вывод
* Аргументы:
* - Строка для вывода.
*
* Приметр макровызова:
* Puts "Текст выводимой строки"
*
* Результат:
* - выводит в стандартный вывод символы заданной строки,
* а также символ перевода строки
*
* После выполнения макровызова изменяются регистры: %eax, %ebx, %ecx,
%edx
* См. также 'man puts', 'man 2 write'
*/
.macro Puts string
.data
	str\@: .ascii "\string\n" # формирование фактической строки для вывода

	strlen\@ = . - str\@ # получение значения длины строки

.text
    movl $4, %eax		# номер сист. вызова write
	movl $1, %ebx		# параметр 1: дескриптор стандартного вывода	
	movl $str\@, %ecx	# параметр 2: адрес памяти с выводимыми символами
	movl $strlen\@, %edx 	# параметр 3: количество байтов для вывода
	int $0x80		    # выполнить системный вызов
.endm

/*
* Макрос вывода числа в системе счисления counts
* Аргументы:
* - число для вывода - num
* - система исчисления - dec
*/
.macro Putnum compos counts
.data

	str\@: .ascii " " # строковая константа
.text

preparation_div\@:

	sub %edi, %edi   # счетчик деления. Изначально равен 0
	movl $0x11, %esi # Количество свободных позиций в строке
	movl \compos, %eax # готовим деление (в eax помещаем наше произведение)

next_digit\@:

	movl $0, %edx    # готовим  деление
	idivl \counts    # делим на основание, частное уходит в ax, остаток в edx
	decl %esi        # уменьшаем количество свободных позиций в строке
	incl %edi        # Увеличиваем счетчик делений
	movb %dl, str\@(%esi) # помещаем в строку остаток
	addb $0x30, str\@(%esi) # получаем символ

	cmpl $0 , %eax   # частное = 0?
	je print_dig\@   # ДА - на вывод строки
	jmp next_digit\@ # НЕТ - продолжвем делить

print_dig\@:
	movl $4, %eax     # номер сист. вызова write
	movl $1, %ebx     # параметр 1: дескриптор стандартного вывода
	movl $str\@, %ecx # параметр 2: адрес памяти с выводимыми символа
	addl %esi, %ecx   
	movl %edi, %edx   # параметр 3: количество выводимых символов
	int $0x80

.endm

/**
 * Программа, суммирующая одноцифровые числа (как положительные, так и отрицательные) и выводящая их в 10 c.c.
 *
 * Copyright (c) 2020, Dasha Efimova <dashulya0301178@gmail.com>
*/

.include "my-macro"

.bss
    .lcomm buf, 10 # буфер для хранения прочитанных символов. Размер - 10 байт
    .lcomm c, 1 # буфер для чтения текущего символа. Размер - 1 байт

.data # секция данных, распределение памяти
      #соотв. конструкция языка C и коммент.
result: .short 0  # Результат суммы (размер 2 байта)
ten:    .word 10  # константа для деления на 10
two:	.word 2   # константа для деления на 2
eight:	.word 8	  # константа для деления на 8

.text                # секция команд процесора 
    .global _start   # точка входа - глобальная метка

_start:
    sub %esi, %esi   # указатель адреса байта в буфере символов (индексный регистр)

kbd_input:
  
        Getchar $c      # макровызов ввода символа со стандартного ввода
        cmpl $0, %eax   # Конец файл - EOF (введено 0 символов) ?
        je stop         # Да - на завершение программы
        cmpb $'\n', c   # это символ перевода строки ?
        je presum       # ДА - пытаемся прибавить последний символ
        cmpb $'-', c    # введен знак минус?
        je write_minus  # ДА - переходим на запись его в буфер
        cmpb $'9', c    # код больше кода символа '9' ?
        ja kbd_input    # ДА - игнорируем его
        cmpb $'0', c    # код меньше кода символа '0' ?
        jb kbd_input    # ДА - игнорируем его
        movb c, %al     # код из с пишем в al
        movb %al, buf(%esi)  # Загрузить содержимое al (введенный символ) в байт по
			                 # адресу buf + esi (буфер для вводимых символов)
        incl %esi       # указать на следующий адрес буфера
        jmp kbd_input   # на ввод следующего символа
		
write_minus:
        movb c, %al     # код из с пишем в al
        movb %al, buf(%esi) # байтовое перемещение, из буфера buf + esi забирается код цифрового символа и размещается в младшем байте %al  
        incl %esi       # указать на следующий адрес буфера 
        jmp kbd_input   # на ввод следующего символа

presum:
        movl $0, %edx   # Подготавливаем регистры для суммы
        movl $0, %ecx
        movl $0, %eax
        movl %esi, %edi # в приемный регистр edi копируем содержимое esi
        decl %esi       # указать на предыдущий адрес буфера 
        jmp check_minus # На проверку отрицательного числа

check_minus: 
        decl %esi        # указать на предыдущий адрес буфера
        cmpl $0, %esi    # значение регистра меньше 0?
        jl plus          # ДА - на установление ecx = 0
        cmpb $'-', buf(%esi)  # в буфере знак минус?
        je minus         # ДА - на установление ecx = 1
        jmp plus         # число положительное, на установление ecx = 0

minus: 
        movw $1, %cx     # помещаем в ecx 1 (значит, число отриц.)
        inc %esi         # указать на следующий адрес буфера 
        jmp summation    # переходим на извлечение числа и суммирование

plus: 
        movw $0, %cx     # помещаем в ecx  (значит, число положит.)
        inc %esi         # указать на следующий адрес буфера 
        jmp summation    # переходим на извлечение числа и суммирование

summation: 
        cmp $-1, %esi    # в esi -1?
        je output        # сразу переходим на вывод
        movw $'0', %bx   # в ebx заносим код 0
        movb buf(%esi), %al # байтовое перемещение, из буфера buf + esi забирается код цифрового символа и размещается в младшем байте %al  
        movb $0, buf(%esi)  # в буфер помещаем 0
        sub %bx, %ax     # преобразовываем код символа цифры в само число
        dec %esi         # указать на предыдущий адрес буфера 
	cmp $1, %cx      # в ecx 1? (было введено отрицательное число?)
        je razn          # ДА - переход на вычитание
        cmp $0, %cx      # в ecx 0? (было введено положительное число?)
        je summ          # ДА - переход на сложение

razn:
        movw result, %bx # копируем результат(сумму) в ebx
        sub %ax, %bx     # пробуем вычесть
        jo error         # если произошло переполнение, то переходим на вывод сообщения
        movw %bx, result # получившуюся сумму переносим обратно в result
        dec %esi         # указать на предыдущий адрес буфера 
        jmp output       # переход на вывод суммы

summ: 
        movw result, %bx # копируем результат(сумму) в ebx
        add %ax, %bx     # пробуем сложить
        jo error         # если произошло переполнение, то переходим на вывод сообщения
        movw %bx, result # получившуюся сумму переносим обратно в result
        jmp output       # переход на вывод суммы

output: 
	mov result, %ax      # помещаем результат(сумму) в eax
	mov $10, %ebx        # помещаем 10 в ebx 
	Putn                 # макровызов для вывода суммы по основанию ebx 
	Putsn                # макровызов вывода строки на стандартный вывод
	movl $0, %esi        # очищаем регистр
	movb $0, buf(%esi)   # очищаем буфер
	jmp kbd_input        # на ввод следующего символа

error:
	Puts "Сумма переполнена. Конец программы" # сообщение о переполнении суммы
	jmp stop                                  # на завершение программы
 
 
stop:
    Exit $0

.end

